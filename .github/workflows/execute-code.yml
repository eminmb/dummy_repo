name: Execute Code on Push

on:
  push:
    branches:
      - main  # Change to your branch if needed

jobs:
  execute-code:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v2

      - name: Set up Python
        uses: actions/setup-python@v2
        with:
          python-version: '3.8'  # Specify the Python version you need

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install requests langchain_community

      - name: Execute Python script
        id: execute_code
        env:
          MY_TOKEN: ${{ secrets.MY_TOKEN }}  # Use your GitHub token stored as a secret
        run: |
          python -c "
import os
import requests
import json
import base64
from langchain_community.llms import Ollama

def fetch_commits(repo_owner, repo_name, token):
    url = f'https://api.github.com/repos/{repo_owner}/{repo_name}/commits'
    headers = {'Authorization': f'token {token}'}
    response = requests.get(url, headers=headers)
    if response.status_code == 200:
        return response.json()
    else:
        raise Exception(f'Failed to fetch commits: {response.status_code} {response.text}')

def fetch_commit_details(repo_owner, repo_name, sha, token):
    url = f'https://api.github.com/repos/{repo_owner}/{repo_name}/commits/{sha}'
    headers = {'Authorization': f'token {token}'}
    response = requests.get(url, headers=headers)
    if response.status_code == 200:
        return response.json()
    else:
        raise Exception(f'Failed to fetch commit details: {response.status_code} {response.text}')

def analyze_with_gemma2(input_text):
    llm = Ollama(model='gemma2')
    response = llm.invoke(input_text)
    return response

def check_message_code_relationship(commit_message, commit_code):
    input_text = f'This is the commit message: {commit_message} This is the committed code: {commit_code} Does the commit message accurately and well express what the code does?'
    return analyze_with_gemma2(input_text)

repo_owner = 'eminmb'
repo_name = 'dummy_repo'
github_token = os.getenv('MY_TOKEN')

commits = fetch_commits(repo_owner, repo_name, github_token)

commit_details = []
for commit in commits:
    sha = commit['sha']
    details = fetch_commit_details(repo_owner, repo_name, sha, github_token)
    commit_details.append(details)

commit_messages_and_code = [
    {
        'message': detail['commit']['message'],
        'files': [{'filename': file['filename'], 'patch': file.get('patch')} for file in detail['files']]
    }
    for detail in commit_details
]

results = []
for commit in commit_messages_and_code[:1]:
    commit_message = json.dumps(commit['message'])
    commit_code = json.dumps(commit['files'])
    output_message_code = check_message_code_relationship(commit_message, commit_code)
    result = f'Message-Code Relationship Analysis Input: This is the commit message: {commit_message} This is the committed code: {commit_code}\nOutput: {output_message_code}\n'

with open('result.txt', 'w') as f:
    f.write('\n'.join(results))
          "

      - name: Add result to job summary
        if: always()  # Ensure this step runs even if previous steps fail
        run: |
          echo "## Execution Result" >> $GITHUB_STEP_SUMMARY
          cat result.txt >> $GITHUB_STEP_SUMMARY
